async fn assert_rcc_configuration(rcc_config: &RCCConfig) -> AnyhowResult<()> {
    let mut rcc_config_diag_command = Command::new(&rcc_config.binary_path);
    rcc_config_diag_command
        .arg("configuration")
        .arg("diagnostics");
    let stdout = String::from_utf8(rcc_config_diag_command.output().await?.stdout)?;
    assert!(stdout.contains("telemetry-enabled                     ...  \"false\""));
    if let RCCProfileConfig::Custom(custom_rcc_profile_config) = &rcc_config.profile_config {
        assert!(stdout.contains(&format!(
            "config-active-profile                 ...  \"{}\"",
            custom_rcc_profile_config.name
        )));
    }
    Ok(())
}

async fn assert_working_directory(
    working_directory: &Utf8Path,
    headed_user_name: &str,
) -> AnyhowResult<()> {
    assert_permissions(
        &working_directory,
        &format!("{headed_user_name}:(OI)(CI)(F)"),
    )
    .await?;
    assert!(working_directory.is_dir());
    assert_eq!(
        directory_entries(working_directory, 1),
        ["environment_building", "plans", "rcc_setup"]
    );
    assert_eq!(
        directory_entries(working_directory.join("rcc_setup"), 1),
        [
            "custom_profile_import_current_user.stderr",
            "custom_profile_import_current_user.stdout",
            &format!("custom_profile_import_user_{headed_user_name}.bat"),
            &format!("custom_profile_import_user_{headed_user_name}.exit_code"),
            &format!("custom_profile_import_user_{headed_user_name}.stderr"),
            &format!("custom_profile_import_user_{headed_user_name}.stdout"),
            "custom_profile_switch_current_user.stderr",
            "custom_profile_switch_current_user.stdout",
            &format!("custom_profile_switch_user_{headed_user_name}.bat"),
            &format!("custom_profile_switch_user_{headed_user_name}.exit_code"),
            &format!("custom_profile_switch_user_{headed_user_name}.stderr"),
            &format!("custom_profile_switch_user_{headed_user_name}.stdout"),
            "holotree_initialization_current_user.stderr",
            "holotree_initialization_current_user.stdout",
            &format!("holotree_initialization_user_{headed_user_name}.bat"),
            &format!("holotree_initialization_user_{headed_user_name}.exit_code"),
            &format!("holotree_initialization_user_{headed_user_name}.stderr"),
            &format!("holotree_initialization_user_{headed_user_name}.stdout"),
            "long_path_support_enabling.stderr",
            "long_path_support_enabling.stdout",
            "telemetry_disabling_current_user.stderr",
            "telemetry_disabling_current_user.stdout",
            &format!("telemetry_disabling_user_{headed_user_name}.bat"),
            &format!("telemetry_disabling_user_{headed_user_name}.exit_code"),
            &format!("telemetry_disabling_user_{headed_user_name}.stderr"),
            &format!("telemetry_disabling_user_{headed_user_name}.stdout")
        ]
    );
    assert_eq!(
        directory_entries(working_directory.join("environment_building"), 1),
        [
            "rcc_headed.bat",
            "rcc_headed.exit_code",
            "rcc_headed.stderr",
            "rcc_headed.stdout",
            "rcc_headless.stderr",
            "rcc_headless.stdout"
        ]
    );
    assert_eq!(
        directory_entries(working_directory.join("plans"), 1),
        ["no_rcc", "rcc_headed", "rcc_headless"]
    );

    // We expliclitly don't check for the rebot files in the case without RCC, since this must also
    // work on systems that don't have the necessary Python environment.
    assert!(!directory_entries(working_directory.join("plans").join("no_rcc"), 1).is_empty());

    let entries_rcc_headed =
        directory_entries(working_directory.join("plans").join("rcc_headed"), 2).join("");
    assert!(entries_rcc_headed.contains("rebot.xml"));
    assert!(entries_rcc_headed.contains("1.bat"));

    let entries_rcc_headless =
        directory_entries(working_directory.join("plans").join("rcc_headless"), 2).join("");
    assert!(entries_rcc_headless.contains("rebot.xml"));
    assert!(!entries_rcc_headless.contains("1.bat"));

    Ok(())
}

fn rcc_setup(
    global_config: &GlobalConfig,
    rcc_plans: Vec<Plan>,
    rcc_setup_failures: &mut RCCSetupFailures,
) -> AnyhowResult<Vec<Plan>> {
    let mut sucessful_plans: Vec<Plan>;

    debug!("Disabling RCC telemetry");
    (sucessful_plans, rcc_setup_failures.telemetry_disabling) =
        disable_rcc_telemetry(global_config, rcc_plans)
            .context("Received termination signal while disabling RCC telemetry")?;
    if !rcc_setup_failures.telemetry_disabling.is_empty() {
        error!(
            "Dropping the following plans due to RCC telemetry disabling failure: {}",
            failed_plan_ids_human_readable(rcc_setup_failures.telemetry_disabling.keys())
        );
    }

    debug!("Configuring RCC profile");
    (sucessful_plans, rcc_setup_failures.profile_configuring) =
        configure_rcc_profile(global_config, sucessful_plans)
            .context("Received termination signal while configuring RCC profile")?;
    if !rcc_setup_failures.profile_configuring.is_empty() {
        error!(
            "Dropping the following plans due to profile configuring failure: {}",
            failed_plan_ids_human_readable(rcc_setup_failures.profile_configuring.keys())
        );
    }

    debug!("Enabling support for long paths");
    (sucessful_plans, rcc_setup_failures.long_path_support) =
        enable_long_path_support(global_config, sucessful_plans)
            .context("Received termination signal while enabling support for long paths")?;
    if !rcc_setup_failures.long_path_support.is_empty() {
        error!(
            "Dropping the following plans due to long path support enabling failure: {}",
            failed_plan_ids_human_readable(rcc_setup_failures.long_path_support.keys())
        );
    }

    debug!("Initializing holotree");
    (sucessful_plans, rcc_setup_failures.holotree_init) =
        holotree_init(global_config, sucessful_plans)
            .context("Received termination signal while initializing holotree")?;
    if !rcc_setup_failures.holotree_init.is_empty() {
        error!(
            "Dropping the following plans due to holotree initialization failure: {}",
            failed_plan_ids_human_readable(rcc_setup_failures.holotree_init.keys())
        );
    }

    Ok(sucessful_plans)
}

