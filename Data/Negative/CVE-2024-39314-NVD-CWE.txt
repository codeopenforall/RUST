async fn main() -> Result<()> {
    setup_logger().unwrap_or_default();
    let args: Args = Args::parse();
    match args.subcommand {
        Commands::Run {
            http_port,
            http_host,
            telnet_port,
            telnet_host,
            cloudflare_support,
            read_bearer_token_from_stdin
        } => {
            let bearer_token = {
                let mut buf = String::new();
                stdin().read_line(&mut buf).expect("failed to read from stdin");
                buf.trim_end().to_string()
            };

            WRITE_TOKEN.set(bearer_token).unwrap();

            let http_server = HttpServer::new(move || {
                let logger_format = if cloudflare_support {
                    r#"%a (CF '%{CF-Connecting-IP}i') %t "%r" %s "%{Referer}i" "%{User-Agent}i" "#
                } else {
                    r#"%a %t "%r" %s "%{Referer}i" "%{User-Agent}i" "#
                };

                App::new()
                    .service(prefixed_service("/api")
                        .service(
                            (
                                prefixed_service("/article")
                                    .service(
                                        (
                                            article::create,
                                            article::fetch,
                                            article::update,
                                            article::remove,
                                        )
                                    ),
                                article::list,
                                prefixed_service("/meta")
                                    .service(meta::change_id)
                            )
                        )
                    )
                    .app_data(
                        BearerAuthConfig::default()
                            .realm("Perform write operation")
                            .scope("article:write"),
                    )
                    .wrap(Logger::new(logger_format))
                    .wrap(cors_middleware_factory())
            });

        tokio::spawn({
            Server::build()
                .bind("echo", (telnet_host, telnet_port), move || {
                    fn_service(move |stream: TcpStream| {
                        telnet_server_service(stream)
                    })
                })?
                .run()
        });

        http_server
                    .bind((http_host, http_port))?
                    .run()
                    .await
                    .context("while running server")?;

                Ok(())
            }
        Commands::Import { file_path, article_id } => {
            if !file_path.exists() {
                bail!("You can not import non-existent file")
            }

            if !file_path.is_file() {
                // TODO: /dev/stdin is not supported by this method
                debug!("is_dir: {}", file_path.is_dir());
                debug!("is_symlink: {}", file_path.is_symlink());
                debug!("metadata: {:?}", file_path.metadata()?);
                bail!("Non-file paths are not supported")
            }

            let content = {
                let mut fd = BufReader::new(File::open(file_path)?);
                let mut buf = vec![];
                fd.read_to_end(&mut buf)?;
                String::from_utf8(buf)
            };

            match content {
                Ok(content) => {
                    GLOBAL_FILE.create_entry(&article_id, content).await?;
                    info!("Successfully imported as {article_id}.");
                    Ok(())
                }
                Err(err) => {
                    bail!("The file is not UTF-8: {err}\
                    Please review following list:\
                    - The file is not binary\
                    - The text is encoded with UTF-8\
                    Especially, importing Shift-JIS texts are NOT supported.")
                }
            }
        }
    }
}

