pub async fn create_cli_main_worker_factory(
    &self,
  ) -> Result<CliMainWorkerFactory, AnyError> {
    let node_resolver = self.node_resolver().await?;
    let npm_resolver = self.npm_resolver().await?;
    let fs = self.fs();
    let cli_node_resolver = self.cli_node_resolver().await?;
    let maybe_file_watcher_communicator = if self.options.has_hmr() {
      Some(self.watcher_communicator.clone().unwrap())
    } else {
      None
    };

    Ok(CliMainWorkerFactory::new(
      StorageKeyResolver::from_options(&self.options),
      self.options.sub_command().clone(),
      npm_resolver.clone(),
      node_resolver.clone(),
      self.blob_store().clone(),
      Box::new(CliModuleLoaderFactory::new(
        &self.options,
        self.emitter()?.clone(),
        self.graph_container().clone(),
        self.module_load_preparer().await?.clone(),
        self.parsed_source_cache().clone(),
        self.resolver().await?.clone(),
        cli_node_resolver.clone(),
        NpmModuleLoader::new(
          self.cjs_resolutions().clone(),
          self.node_code_translator().await?.clone(),
          fs.clone(),
          cli_node_resolver.clone(),
        ),
      )),
      self.root_cert_store_provider().clone(),
      self.fs().clone(),
      Some(self.emitter()?.clone()),
      maybe_file_watcher_communicator,
      self.maybe_inspector_server().clone(),
      self.maybe_lockfile().clone(),
      self.feature_checker().clone(),
      self.create_cli_main_worker_options()?,
    ))
  }

fn create_command(
  state: &mut OpState,
  args: SpawnArgs,
  api_name: &str,
) -> Result<CreateCommand, AnyError> {
  state
    .borrow_mut::<PermissionsContainer>()
    .check_run(&args.cmd, api_name)?;

  let mut command = std::process::Command::new(args.cmd);

  #[cfg(windows)]
  if args.windows_raw_arguments {
    for arg in args.args.iter() {
      command.raw_arg(arg);
    }
  } else {
    command.args(args.args);
  }

  #[cfg(not(windows))]
  command.args(args.args);

  if let Some(cwd) = args.cwd {
    command.current_dir(cwd);
  }

  if args.clear_env {
    command.env_clear();
  }
  command.envs(args.env);

  #[cfg(unix)]
  if let Some(gid) = args.gid {
    command.gid(gid);
  }
  #[cfg(unix)]
  if let Some(uid) = args.uid {
    command.uid(uid);
  }

  command.stdin(args.stdio.stdin.as_stdio());
  command.stdout(match args.stdio.stdout {
    Stdio::Inherit => StdioOrRid::Rid(1).as_stdio(state)?,
    value => value.as_stdio(),
  });
  command.stderr(match args.stdio.stderr {
    Stdio::Inherit => StdioOrRid::Rid(2).as_stdio(state)?,
    value => value.as_stdio(),
  });

  #[cfg(unix)]
  // TODO(bartlomieju):
  #[allow(clippy::undocumented_unsafe_blocks)]
  unsafe {
    if let Some(ipc) = args.ipc {
      if ipc < 0 {
        return Ok((command, None));
      }
      // SockFlag is broken on macOS
      // https://github.com/nix-rust/nix/issues/861
      let mut fds = [-1, -1];
      #[cfg(not(target_os = "macos"))]
      let flags = libc::SOCK_CLOEXEC | libc::SOCK_NONBLOCK;

      #[cfg(target_os = "macos")]
      let flags = 0;

      let ret = libc::socketpair(
        libc::AF_UNIX,
        libc::SOCK_STREAM | flags,
        0,
        fds.as_mut_ptr(),
      );
      if ret != 0 {
        return Err(std::io::Error::last_os_error().into());
      }

      if cfg!(target_os = "macos") {
        let fcntl =
          |fd: i32, flag: libc::c_int| -> Result<(), std::io::Error> {
            let flags = libc::fcntl(fd, libc::F_GETFL, 0);

            if flags == -1 {
              return Err(fail(fds));
            }
            let ret = libc::fcntl(fd, libc::F_SETFL, flags | flag);
            if ret == -1 {
              return Err(fail(fds));
            }
            Ok(())
          };

        fn fail(fds: [i32; 2]) -> std::io::Error {
          unsafe {
            libc::close(fds[0]);
            libc::close(fds[1]);
          }
          std::io::Error::last_os_error()
        }

        // SOCK_NONBLOCK is not supported on macOS.
        (fcntl)(fds[0], libc::O_NONBLOCK)?;
        (fcntl)(fds[1], libc::O_NONBLOCK)?;

        // SOCK_CLOEXEC is not supported on macOS.
        (fcntl)(fds[0], libc::FD_CLOEXEC)?;
        (fcntl)(fds[1], libc::FD_CLOEXEC)?;
      }

      let fd1 = fds[0];
      let fd2 = fds[1];

      command.pre_exec(move || {
        if ipc >= 0 {
          let _fd = libc::dup2(fd2, ipc);
          libc::close(fd2);
        }
        libc::setgroups(0, std::ptr::null());
        Ok(())
      });

      /* One end returned to parent process (this) */
      let pipe_fd = Some(fd1);

      /* The other end passed to child process via DENO_CHANNEL_FD */
      command.env("DENO_CHANNEL_FD", format!("{}", ipc));

      return Ok((command, pipe_fd));
    }

    Ok((command, None))
  }

  #[cfg(not(unix))]
  return Ok((command, None));
}

pub async fn create_custom_worker(
    &self,
    main_module: ModuleSpecifier,
    permissions: PermissionsContainer,
    custom_extensions: Vec<Extension>,
    stdio: deno_runtime::deno_io::Stdio,
  ) -> Result<CliMainWorker, AnyError> {
    let shared = &self.shared;
    let (main_module, is_main_cjs) = if let Ok(package_ref) =
      NpmPackageReqReference::from_specifier(&main_module)
    {
      let package_ref = if package_ref.req().version_req.version_text() == "*" {
        // When using the wildcard version, select the same version used in the
        // package.json deps in order to prevent adding new dependency version
        shared
          .options
          .maybe_root_package_json_deps
          .as_ref()
          .and_then(|deps| {
            deps
              .values()
              .filter_map(|v| v.as_ref().ok())
              .find(|dep| dep.name == package_ref.req().name)
              .map(|dep| {
                NpmPackageReqReference::new(PackageReqReference {
                  req: dep.clone(),
                  sub_path: package_ref.sub_path().map(|s| s.to_string()),
                })
              })
          })
          .unwrap_or(package_ref)
      } else {
        package_ref
      };
      if let Some(npm_resolver) = shared.npm_resolver.as_managed() {
        npm_resolver
          .add_package_reqs(&[package_ref.req().clone()])
          .await?;
      }

      // use a fake referrer that can be used to discover the package.json if necessary
      let referrer =
        ModuleSpecifier::from_directory_path(self.shared.fs.cwd()?)
          .unwrap()
          .join("package.json")?;
      let package_folder = shared
        .npm_resolver
        .resolve_pkg_folder_from_deno_module_req(
          package_ref.req(),
          &referrer,
        )?;
      let node_resolution = self.resolve_binary_entrypoint(
        &package_folder,
        package_ref.sub_path(),
        &permissions,
      )?;
      let is_main_cjs = matches!(node_resolution, NodeResolution::CommonJs(_));

      if let Some(lockfile) = &shared.maybe_lockfile {
        // For npm binary commands, ensure that the lockfile gets updated
        // so that we can re-use the npm resolution the next time it runs
        // for better performance
        lockfile
          .lock()
          .write()
          .context("Failed writing lockfile.")?;
      }

      (node_resolution.into_url(), is_main_cjs)
    } else if shared.options.is_npm_main
      || shared.node_resolver.in_npm_package(&main_module)
    {
      let node_resolution =
        shared.node_resolver.url_to_node_resolution(main_module)?;
      let is_main_cjs = matches!(node_resolution, NodeResolution::CommonJs(_));
      (node_resolution.into_url(), is_main_cjs)
    } else {
      (main_module, false)
    };

    let module_loader = shared
      .module_loader_factory
      .create_for_main(PermissionsContainer::allow_all(), permissions.clone());
    let maybe_source_map_getter =
      shared.module_loader_factory.create_source_map_getter();
    let maybe_inspector_server = shared.maybe_inspector_server.clone();

    let create_web_worker_cb =
      create_web_worker_callback(shared.clone(), stdio.clone());

    let maybe_storage_key = shared
      .storage_key_resolver
      .resolve_storage_key(&main_module);
    let origin_storage_dir = maybe_storage_key.as_ref().map(|key| {
      shared
        .options
        .origin_data_folder_path
        .as_ref()
        .unwrap() // must be set if storage key resolver returns a value
        .join(checksum::gen(&[key.as_bytes()]))
    });
    let cache_storage_dir = maybe_storage_key.map(|key| {
      // TODO(@satyarohith): storage quota management
      // Note: we currently use temp_dir() to avoid managing storage size.
      std::env::temp_dir()
        .join("deno_cache")
        .join(checksum::gen(&[key.as_bytes()]))
    });

    // TODO(bartlomieju): this is cruft, update FeatureChecker to spit out
    // list of enabled features.
    let feature_checker = shared.feature_checker.clone();
    let mut unstable_features =
      Vec::with_capacity(crate::UNSTABLE_GRANULAR_FLAGS.len());
    for (feature_name, _, id) in crate::UNSTABLE_GRANULAR_FLAGS {
      if feature_checker.check(feature_name) {
        unstable_features.push(*id);
      }
    }

    let options = WorkerOptions {
      bootstrap: BootstrapOptions {
        args: shared.options.argv.clone(),
        cpu_count: std::thread::available_parallelism()
          .map(|p| p.get())
          .unwrap_or(1),
        log_level: shared.options.log_level,
        enable_op_summary_metrics: shared.options.enable_op_summary_metrics,
        enable_testing_features: shared.options.enable_testing_features,
        locale: deno_core::v8::icu::get_language_tag(),
        location: shared.options.location.clone(),
        no_color: !colors::use_color(),
        is_tty: colors::is_tty(),
        unstable: shared.options.unstable,
        unstable_features,
        user_agent: version::get_user_agent().to_string(),
        inspect: shared.options.is_inspecting,
        has_node_modules_dir: shared.options.has_node_modules_dir,
        maybe_binary_npm_command_name: shared
          .options
          .maybe_binary_npm_command_name
          .clone(),
      },
      extensions: custom_extensions,
      startup_snapshot: crate::js::deno_isolate_init(),
      create_params: None,
      unsafely_ignore_certificate_errors: shared
        .options
        .unsafely_ignore_certificate_errors
        .clone(),
      root_cert_store_provider: Some(shared.root_cert_store_provider.clone()),
      seed: shared.options.seed,
      source_map_getter: maybe_source_map_getter,
      format_js_error_fn: Some(Arc::new(format_js_error)),
      create_web_worker_cb,
      maybe_inspector_server,
      should_break_on_first_statement: shared.options.inspect_brk,
      should_wait_for_inspector_session: shared.options.inspect_wait,
      strace_ops: shared.options.strace_ops.clone(),
      module_loader,
      fs: shared.fs.clone(),
      npm_resolver: Some(shared.npm_resolver.clone().into_npm_resolver()),
      get_error_class_fn: Some(&errors::get_error_class_name),
      cache_storage_dir,
      origin_storage_dir,
      blob_store: shared.blob_store.clone(),
      broadcast_channel: shared.broadcast_channel.clone(),
      shared_array_buffer_store: Some(shared.shared_array_buffer_store.clone()),
      compiled_wasm_module_store: Some(
        shared.compiled_wasm_module_store.clone(),
      ),
      stdio,
      feature_checker,
      skip_op_registration: shared.options.skip_op_registration,
    };

    let mut worker = MainWorker::bootstrap_from_options(
      main_module.clone(),
      permissions,
      options,
    );

    if self.shared.subcommand.needs_test() {
      worker.js_runtime.lazy_load_es_module_from_code(
        "ext:cli/40_testing.js",
        deno_core::FastString::StaticAscii(include_str!("js/40_testing.js")),
      )?;
      worker.js_runtime.lazy_load_es_module_from_code(
        "ext:cli/40_jupyter.js",
        deno_core::FastString::StaticAscii(include_str!("js/40_jupyter.js")),
      )?;
    }

    Ok(CliMainWorker {
      main_module,
      is_main_cjs,
      worker,
      shared: shared.clone(),
    })
  }

fn create_web_worker_callback(
  shared: Arc<SharedWorkerState>,
  stdio: deno_runtime::deno_io::Stdio,
) -> Arc<CreateWebWorkerCb> {
  Arc::new(move |args| {
    let maybe_inspector_server = shared.maybe_inspector_server.clone();

    let module_loader = shared.module_loader_factory.create_for_worker(
      args.parent_permissions.clone(),
      args.permissions.clone(),
    );
    let maybe_source_map_getter =
      shared.module_loader_factory.create_source_map_getter();
    let create_web_worker_cb =
      create_web_worker_callback(shared.clone(), stdio.clone());

    let maybe_storage_key = shared
      .storage_key_resolver
      .resolve_storage_key(&args.main_module);
    let cache_storage_dir = maybe_storage_key.map(|key| {
      // TODO(@satyarohith): storage quota management
      // Note: we currently use temp_dir() to avoid managing storage size.
      std::env::temp_dir()
        .join("deno_cache")
        .join(checksum::gen(&[key.as_bytes()]))
    });

    // TODO(bartlomieju): this is cruft, update FeatureChecker to spit out
    // list of enabled features.
    let feature_checker = shared.feature_checker.clone();
    let mut unstable_features =
      Vec::with_capacity(crate::UNSTABLE_GRANULAR_FLAGS.len());
    for (feature_name, _, id) in crate::UNSTABLE_GRANULAR_FLAGS {
      if feature_checker.check(feature_name) {
        unstable_features.push(*id);
      }
    }

    let options = WebWorkerOptions {
      bootstrap: BootstrapOptions {
        args: shared.options.argv.clone(),
        cpu_count: std::thread::available_parallelism()
          .map(|p| p.get())
          .unwrap_or(1),
        log_level: shared.options.log_level,
        enable_op_summary_metrics: shared.options.enable_op_summary_metrics,
        enable_testing_features: shared.options.enable_testing_features,
        locale: deno_core::v8::icu::get_language_tag(),
        location: Some(args.main_module.clone()),
        no_color: !colors::use_color(),
        is_tty: colors::is_tty(),
        unstable: shared.options.unstable,
        unstable_features,
        user_agent: version::get_user_agent().to_string(),
        inspect: shared.options.is_inspecting,
        has_node_modules_dir: shared.options.has_node_modules_dir,
        maybe_binary_npm_command_name: shared
          .options
          .maybe_binary_npm_command_name
          .clone(),
      },
      extensions: vec![],
      startup_snapshot: crate::js::deno_isolate_init(),
      unsafely_ignore_certificate_errors: shared
        .options
        .unsafely_ignore_certificate_errors
        .clone(),
      root_cert_store_provider: Some(shared.root_cert_store_provider.clone()),
      seed: shared.options.seed,
      create_web_worker_cb,
      format_js_error_fn: Some(Arc::new(format_js_error)),
      source_map_getter: maybe_source_map_getter,
      module_loader,
      fs: shared.fs.clone(),
      npm_resolver: Some(shared.npm_resolver.clone().into_npm_resolver()),
      worker_type: args.worker_type,
      maybe_inspector_server,
      get_error_class_fn: Some(&errors::get_error_class_name),
      blob_store: shared.blob_store.clone(),
      broadcast_channel: shared.broadcast_channel.clone(),
      shared_array_buffer_store: Some(shared.shared_array_buffer_store.clone()),
      compiled_wasm_module_store: Some(
        shared.compiled_wasm_module_store.clone(),
      ),
      stdio: stdio.clone(),
      cache_storage_dir,
      feature_checker,
    };

    WebWorker::bootstrap_from_options(
      args.name,
      args.permissions,
      args.main_module,
      args.worker_id,
      options,
    )
  })
}

fn default() -> Self {
    let cpu_count = thread::available_parallelism()
      .map(|p| p.get())
      .unwrap_or(1);

    let runtime_version = env!("CARGO_PKG_VERSION");
    let user_agent = format!("Deno/{runtime_version}");

    Self {
      user_agent,
      cpu_count,
      no_color: !colors::use_color(),
      is_tty: colors::is_tty(),
      enable_op_summary_metrics: Default::default(),
      enable_testing_features: Default::default(),
      log_level: Default::default(),
      locale: "en".to_string(),
      location: Default::default(),
      unstable: Default::default(),
      unstable_features: Default::default(),
      inspect: Default::default(),
      args: Default::default(),
      has_node_modules_dir: Default::default(),
      maybe_binary_npm_command_name: None,
    }
  }





fn from_unix_stream(stream: UnixStream) -> Self {
      let (read_half, write_half) = stream.into_split();
      Self {
        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),
        write_half: AsyncRefCell::new(write_half),
        cancel: Default::default(),
      }
    }



fn new(stream: RawFd) -> Result<Self, std::io::Error> {
      // Safety: The fd is part of a pair of connected sockets create by child process
      // implementation.
      let unix_stream = UnixStream::from_std(unsafe {
        std::os::unix::net::UnixStream::from_raw_fd(stream)
      })?;
      let (read_half, write_half) = unix_stream.into_split();
      Ok(Self {
        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),
        write_half: AsyncRefCell::new(write_half),
        cancel: Default::default(),
      })
    }

pub fn node_ipc_fd(&self) -> Option<i32> {
    let maybe_node_channel_fd = std::env::var("DENO_CHANNEL_FD").ok();
    if let Some(node_channel_fd) = maybe_node_channel_fd {
      // Remove so that child processes don't inherit this environment variable.
      std::env::remove_var("DENO_CHANNEL_FD");
      node_channel_fd.parse::<i32>().ok()
    } else {
      None
    }
  }

pub fn op_node_ipc_pipe(
    state: &mut OpState,
    #[smi] fd: i32,
  ) -> Result<ResourceId, AnyError> {
    Ok(state.resource_table.add(IpcJsonStreamResource::new(fd)?))
  }





fn op_spawn_child(
  state: &mut OpState,
  #[serde] args: SpawnArgs,
  #[string] api_name: String,
) -> Result<Child, AnyError> {
  let (command, pipe_fd) = create_command(state, args, &api_name)?;
  spawn_child(state, command, pipe_fd)
}

fn op_spawn_sync(
  state: &mut OpState,
  #[serde] args: SpawnArgs,
) -> Result<SpawnOutput, AnyError> {
  let stdout = matches!(args.stdio.stdout, Stdio::Piped);
  let stderr = matches!(args.stdio.stderr, Stdio::Piped);
  let mut command = create_command(state, args, "Deno.Command().outputSync()")?;
  let output = command.output().with_context(|| {
    format!(
      "Failed to spawn '{}'",
      command.get_program().to_string_lossy()
    )
  })?;

  Ok(SpawnOutput {
    status: output.status.try_into()?,
    stdout: if stdout {
      Some(output.stdout.into())
    } else {
      None
    },
    stderr: if stderr {
      Some(output.stderr.into())
    } else {
      None
    },
  })
}





pub async fn run(
  mut eszip: eszip::EszipV2,
  metadata: Metadata,
) -> Result<(), AnyError> {
  let main_module = &metadata.entrypoint;
  let current_exe_path = std::env::current_exe().unwrap();
  let current_exe_name =
    current_exe_path.file_name().unwrap().to_string_lossy();
  let deno_dir_provider = Arc::new(DenoDirProvider::new(None));
  let root_cert_store_provider = Arc::new(StandaloneRootCertStoreProvider {
    ca_stores: metadata.ca_stores,
    ca_data: metadata.ca_data.map(CaData::Bytes),
    cell: Default::default(),
  });
  let progress_bar = ProgressBar::new(ProgressBarStyle::TextOnly);
  let http_client = Arc::new(HttpClient::new(
    Some(root_cert_store_provider.clone()),
    metadata.unsafely_ignore_certificate_errors.clone(),
  ));
  // use a dummy npm registry url
  let npm_registry_url = ModuleSpecifier::parse("https://localhost/").unwrap();
  let root_path = std::env::temp_dir()
    .join(format!("deno-compile-{}", current_exe_name))
    .join("node_modules");
  let npm_cache_dir = NpmCacheDir::new(root_path.clone());
  let npm_global_cache_dir = npm_cache_dir.get_cache_location();
  let cache_setting = CacheSetting::Only;
  let (package_json_deps_provider, fs, npm_resolver, maybe_vfs_root) =
    match metadata.node_modules {
      Some(binary::NodeModules::Managed {
        node_modules_dir,
        package_json_deps,
      }) => {
        // this will always have a snapshot
        let snapshot = eszip.take_npm_snapshot().unwrap();
        let vfs_root_dir_path = if node_modules_dir {
          root_path
        } else {
          npm_cache_dir.registry_folder(&npm_registry_url)
        };
        let vfs = load_npm_vfs(vfs_root_dir_path.clone())
          .context("Failed to load npm vfs.")?;
        let maybe_node_modules_path = if node_modules_dir {
          Some(vfs.root().to_path_buf())
        } else {
          None
        };
        let package_json_deps_provider =
          Arc::new(PackageJsonDepsProvider::new(
            package_json_deps.map(|serialized| serialized.into_deps()),
          ));
        let fs = Arc::new(DenoCompileFileSystem::new(vfs))
          as Arc<dyn deno_fs::FileSystem>;
        let npm_resolver = create_cli_npm_resolver(
          CliNpmResolverCreateOptions::Managed(CliNpmResolverManagedCreateOptions {
            snapshot: CliNpmResolverManagedSnapshotOption::Specified(Some(snapshot)),
            maybe_lockfile: None,
            fs: fs.clone(),
            http_client: http_client.clone(),
            npm_global_cache_dir,
            cache_setting,
            text_only_progress_bar: progress_bar,
            maybe_node_modules_path,
            package_json_installer:
              CliNpmResolverManagedPackageJsonInstallerOption::ConditionalInstall(
                package_json_deps_provider.clone(),
              ),
            npm_registry_url,
            npm_system_info: Default::default(),
          }),
        )
        .await?;
        (
          package_json_deps_provider,
          fs,
          npm_resolver,
          Some(vfs_root_dir_path),
        )
      }
      Some(binary::NodeModules::Byonm { package_json_deps }) => {
        let vfs_root_dir_path = root_path;
        let vfs = load_npm_vfs(vfs_root_dir_path.clone())
          .context("Failed to load npm vfs.")?;
        let node_modules_path = vfs.root().join("node_modules");
        let package_json_deps_provider =
          Arc::new(PackageJsonDepsProvider::new(
            package_json_deps.map(|serialized| serialized.into_deps()),
          ));
        let fs = Arc::new(DenoCompileFileSystem::new(vfs))
          as Arc<dyn deno_fs::FileSystem>;
        let npm_resolver =
          create_cli_npm_resolver(CliNpmResolverCreateOptions::Byonm(
            CliNpmResolverByonmCreateOptions {
              fs: fs.clone(),
              root_node_modules_dir: node_modules_path,
            },
          ))
          .await?;
        (
          package_json_deps_provider,
          fs,
          npm_resolver,
          Some(vfs_root_dir_path),
        )
      }
      None => {
        let package_json_deps_provider =
          Arc::new(PackageJsonDepsProvider::new(None));
        let fs = Arc::new(deno_fs::RealFs) as Arc<dyn deno_fs::FileSystem>;
        let npm_resolver = create_cli_npm_resolver(
          CliNpmResolverCreateOptions::Managed(CliNpmResolverManagedCreateOptions {
            snapshot: CliNpmResolverManagedSnapshotOption::Specified(None),
            maybe_lockfile: None,
            fs: fs.clone(),
            http_client: http_client.clone(),
            npm_global_cache_dir,
            cache_setting,
            text_only_progress_bar: progress_bar,
            maybe_node_modules_path: None,
            package_json_installer:
              CliNpmResolverManagedPackageJsonInstallerOption::ConditionalInstall(
                package_json_deps_provider.clone(),
              ),
            npm_registry_url,
            npm_system_info: Default::default(),
          }),
        )
        .await?;
        (package_json_deps_provider, fs, npm_resolver, None)
      }
    };

  let has_node_modules_dir = npm_resolver.root_node_modules_path().is_some();
  let node_resolver = Arc::new(NodeResolver::new(
    fs.clone(),
    npm_resolver.clone().into_npm_resolver(),
  ));
  let cjs_resolutions = Arc::new(CjsResolutionStore::default());
  let cache_db = Caches::new(deno_dir_provider.clone());
  let node_analysis_cache = NodeAnalysisCache::new(cache_db.node_analysis_db());
  let cjs_esm_code_analyzer =
    CliCjsCodeAnalyzer::new(node_analysis_cache, fs.clone());
  let node_code_translator = Arc::new(NodeCodeTranslator::new(
    cjs_esm_code_analyzer,
    fs.clone(),
    node_resolver.clone(),
    npm_resolver.clone().into_npm_resolver(),
  ));
  let maybe_import_map = metadata.maybe_import_map.map(|(base, source)| {
    Arc::new(parse_from_json(&base, &source).unwrap().import_map)
  });
  let cli_node_resolver = Arc::new(CliNodeResolver::new(
    cjs_resolutions.clone(),
    node_resolver.clone(),
    npm_resolver.clone(),
  ));
  let module_loader_factory = StandaloneModuleLoaderFactory {
    shared: Arc::new(SharedModuleLoaderState {
      eszip,
      mapped_specifier_resolver: MappedSpecifierResolver::new(
        maybe_import_map.clone(),
        package_json_deps_provider.clone(),
      ),
      node_resolver: cli_node_resolver.clone(),
      npm_module_loader: Arc::new(NpmModuleLoader::new(
        cjs_resolutions,
        node_code_translator,
        fs.clone(),
        cli_node_resolver,
      )),
    }),
  };

  let permissions = {
    let mut permissions = metadata.permissions;
    // if running with an npm vfs, grant read access to it
    if let Some(vfs_root) = maybe_vfs_root {
      match &mut permissions.allow_read {
        Some(vec) if vec.is_empty() => {
          // do nothing, already granted
        }
        Some(vec) => {
          vec.push(vfs_root);
        }
        None => {
          permissions.allow_read = Some(vec![vfs_root]);
        }
      }
    }

    PermissionsContainer::new(Permissions::from_options(&permissions)?)
  };
  let feature_checker = Arc::new({
    let mut checker = FeatureChecker::default();
    checker.set_exit_cb(Box::new(crate::unstable_exit_cb));
    // TODO(bartlomieju): enable, once we deprecate `--unstable` in favor
    // of granular --unstable-* flags.
    // feature_checker.set_warn_cb(Box::new(crate::unstable_warn_cb));
    if metadata.unstable {
      checker.enable_legacy_unstable();
    }
    checker
  });
  let worker_factory = CliMainWorkerFactory::new(
    StorageKeyResolver::empty(),
    crate::args::DenoSubcommand::Run(Default::default()),
    npm_resolver,
    node_resolver,
    Default::default(),
    Box::new(module_loader_factory),
    root_cert_store_provider,
    fs,
    None,
    None,
    None,
    None,
    feature_checker,
    CliMainWorkerOptions {
      argv: metadata.argv,
      log_level: WorkerLogLevel::Info,
      coverage_dir: None,
      enable_op_summary_metrics: false,
      enable_testing_features: false,
      has_node_modules_dir,
      hmr: false,
      inspect_brk: false,
      inspect_wait: false,
      strace_ops: None,
      is_inspecting: false,
      is_npm_main: main_module.scheme() == "npm",
      skip_op_registration: true,
      location: metadata.location,
      maybe_binary_npm_command_name: NpmPackageReqReference::from_specifier(
        main_module,
      )
      .ok()
      .map(|req_ref| npm_pkg_req_ref_to_binary_command(&req_ref)),
      origin_data_folder_path: None,
      seed: metadata.seed,
      unsafely_ignore_certificate_errors: metadata
        .unsafely_ignore_certificate_errors,
      unstable: metadata.unstable,
      maybe_root_package_json_deps: package_json_deps_provider.deps().cloned(),
    },
  );

  v8_set_flags(construct_v8_flags(&[], &metadata.v8_flags, vec![]));

  let mut worker = worker_factory
    .create_main_worker(main_module.clone(), permissions)
    .await?;

  let exit_code = worker.run().await?;
  std::process::exit(exit_code)
}

fn spawn_child(
  state: &mut OpState,
  command: std::process::Command,
  pipe_fd: Option<i32>,
) -> Result<Child, AnyError> {
  let mut command = tokio::process::Command::from(command);
  // TODO(@crowlkats): allow detaching processes.
  //  currently deno will orphan a process when exiting with an error or Deno.exit()
  // We want to kill child when it's closed
  command.kill_on_drop(true);

  let mut child = match command.spawn() {
    Ok(child) => child,
    Err(err) => {
      let command = command.as_std();
      let command_name = command.get_program().to_string_lossy();

      if let Some(cwd) = command.get_current_dir() {
        // launching a sub process always depends on the real
        // file system so using these methods directly is ok
        #[allow(clippy::disallowed_methods)]
        if !cwd.exists() {
          return Err(
            std::io::Error::new(
              std::io::ErrorKind::NotFound,
              format!(
                "Failed to spawn '{}': No such cwd '{}'",
                command_name,
                cwd.to_string_lossy()
              ),
            )
            .into(),
          );
        }

        #[allow(clippy::disallowed_methods)]
        if !cwd.is_dir() {
          return Err(
            std::io::Error::new(
              std::io::ErrorKind::NotFound,
              format!(
                "Failed to spawn '{}': cwd is not a directory '{}'",
                command_name,
                cwd.to_string_lossy()
              ),
            )
            .into(),
          );
        }
      }

      return Err(AnyError::from(err).context(format!(
        "Failed to spawn '{}'",
        command.get_program().to_string_lossy()
      )));
    }
  };

  let pid = child.id().expect("Process ID should be set.");

  let stdin_rid = child
    .stdin
    .take()
    .map(|stdin| state.resource_table.add(ChildStdinResource::from(stdin)));

  let stdout_rid = child
    .stdout
    .take()
    .map(|stdout| state.resource_table.add(ChildStdoutResource::from(stdout)));

  let stderr_rid = child
    .stderr
    .take()
    .map(|stderr| state.resource_table.add(ChildStderrResource::from(stderr)));

  let child_rid = state
    .resource_table
    .add(ChildResource(RefCell::new(child), pid));

  Ok(Child {
    rid: child_rid,
    pid,
    stdin_rid,
    stdout_rid,
    stderr_rid,
    pipe_fd,
  })
}

