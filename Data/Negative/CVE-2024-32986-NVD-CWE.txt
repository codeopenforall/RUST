pub fn categories(&self) -> Vec<String> {
        match &self.config.categories {
            Some(categories) => categories,
            None => &self.manifest.categories,
        }
        .iter()
        .map(|item| sanitize_string(item))
        .collect()
    }

fn create_appinfo(args: &IntegrationInstallArgs, appid: &str, appinfo: &Path) -> Result<()> {
    // Process some known manifest categories and reformat them into PortableApps.com names
    // Apps can only have one category, so we will only use the first one
    let category = if let Some(category) = args.site.categories().first() {
        // Make category lower-case and remove all word separators for easier matching
        let category = normalize_category_name(category);

        // Get the mapped PortableApps.com category based on the web app categories
        match PORTABLEAPPS_CATEGORIES.get(&category) {
            Some(category) => category,
            None => "",
        }
    } else {
        ""
    };

    // Create an app info file and fill required info
    let mut config = Ini::new_cs();
    config.set("Format", "Type", Some("PortableAppsFormat".into()));
    config.set("Format", "Version", Some("3.7".into()));
    config.set("Details", "Name", Some(format!("{} Portable", args.site.name())));
    config.set("Details", "Description", args.site.description().into());
    config.set("Details", "Category", Some(category.into()));
    config.set("Details", "Publisher", Some(args.site.domain()));
    config.set("Details", "Homepage", Some(args.site.url()));
    config.set("Details", "AppId", Some(appid.into()));
    config.set("Details", "Language", Some("Multilingual".into()));
    config.set("Version", "PackageVersion", Some("0.0.0.0".into()));
    config.set("Version", "DisplayVersion", Some("0.0.0".into()));
    config.set("Dependencies", "Requires64bitOS", Some("yes".into()));
    config.set("Dependencies", "RequiresPortableApp", Some("PWAsForFirefoxPortable".into()));
    config.set("Control", "Start", Some("launch.vbs".into()));
    config.set("Control", "BaseAppID", Some(appid.into()));

    let protocols = args
        .site
        .config
        .enabled_protocol_handlers
        .iter()
        .map(|item| sanitize_string(item))
        .collect::<Vec<_>>()
        .join(",");

    config.set("Associations", "Protocols", Some(protocols));
    config.set("Associations", "ProtocolCommandLine", Some("--protocol \"%1\"".into()));

    config.write(appinfo)?;
    Ok(())
}

fn create_app_bundle(args: &IntegrationInstallArgs) -> Result<()> {
    let exe = args.dirs.executables.join("firefoxpwa").display().to_string();
    let ulid = args.site.ulid.to_string();
    let appid = format!("FFPWA-{ulid}");
    let bundleid = format!("si.filips.firefoxpwa.site.{ulid}");
    let name = args.site.name();

    // Process some known manifest categories and reformat them into Apple names
    // Apps can only have one category, so we will only use the first one
    let category = if let Some(category) = args.site.categories().first() {
        // Make category lower-case and remove all word separators for easier matching
        let category = normalize_category_name(category);

        // Get the mapped Apple category based on the web app categories
        match MACOS_CATEGORIES.get(&category) {
            Some(category) => category,
            None => "",
        }
    } else {
        ""
    };

    // Get the applications directory and other paths
    let directory = directories::BaseDirs::new()
        .context(BASE_DIRECTORIES_ERROR)?
        .home_dir()
        .join("Applications");

    let bundle = directory.join(format!("{}.app", sanitize_name(&name, &ulid)));
    let bundle_contents = bundle.join("Contents");
    let info_plist = bundle_contents.join("Info.plist");
    let pkg_info = bundle_contents.join("PkgInfo");
    let binary_dir = bundle_contents.join("MacOS");
    let resources_dir = bundle_contents.join("Resources");
    let loader = binary_dir.join("loader");

    // If the name has been changed, first rename the bundle directory
    if let Some(old_name) = &args.old_name {
        let old_bundle = directory.join(format!("{}.app", sanitize_name(old_name, &ulid)));
        let _ = rename(old_bundle, &bundle);
    }

    // Create the bundle directory
    create_dir_all(&bundle_contents).context(CREATE_APPLICATION_DIRECTORY_ERROR)?;
    create_dir_all(binary_dir).context(CREATE_APPLICATION_DIRECTORY_ERROR)?;
    create_dir_all(&resources_dir).context(CREATE_APPLICATION_DIRECTORY_ERROR)?;

    // Store the entry data
    let protocols = args
        .site
        .config
        .enabled_protocol_handlers
        .iter()
        .map(|protocol| {
            let protocol = sanitize_string(protocol);
            let mut handler = plist::dictionary::Dictionary::new();
            handler.insert("CFBundleURLName".into(), format!("{protocol} URL").into());
            handler.insert("CFBundleURLSchemes".into(), vec![protocol.into()].into());
            handler.into()
        })
        .collect::<Vec<plist::Value>>();

    // FIXME: Protocol handlers do not work, they need to be fixed in the future

    let mut info_plist_dict = plist::dictionary::Dictionary::new();
    info_plist_dict.insert("CFBundlePackageType".into(), "APPL".into());
    info_plist_dict.insert("CFBundleIdentifier".into(), bundleid.into());
    info_plist_dict.insert("LSApplicationCategoryType".into(), category.into());
    info_plist_dict.insert("CFBundleName".into(), name.clone().into());
    info_plist_dict.insert("CFBundleVersion".into(), "1.0.0".into());
    info_plist_dict.insert("CFBundleShortVersionString".into(), "1.0.0".into());
    info_plist_dict.insert("CFBundleInfoDictionaryVersion".into(), "6.0".into());
    info_plist_dict.insert("CFBundleSignature".into(), appid.clone().into());
    info_plist_dict.insert("CFBundleDevelopmentRegion".into(), "en".into());
    info_plist_dict.insert("CFBundleExecutable".into(), "loader".into());
    info_plist_dict.insert("CFBundleIconFile".into(), "app.icns".into());
    info_plist_dict.insert("NSHighResolutionCapable".into(), true.into());
    info_plist_dict.insert("CFBundleURLTypes".into(), protocols.into());
    info_plist_dict.insert(
        "NSCameraUsageDescription".into(),
        "Only sites you allow within Firefox will be able to use the camera.".into(),
    );
    info_plist_dict.insert(
        "NSMicrophoneUsageDescription".into(),
        "Only sites you allow within Firefox will be able to use the microphone.".into(),
    );
    let info_plist_value: plist::Value = info_plist_dict.into();

    plist::to_file_xml(info_plist, &info_plist_value).context(WRITE_APPLICATION_FILE_ERROR)?;
    write(pkg_info, format!("APPL{appid}")).context(WRITE_APPLICATION_FILE_ERROR)?;

    // Create and compile loader executable using Swift compiler
    // Swift compiler (swiftc) is part of Command Line Tools for Xcode which is required by Homebrew
    // We can assume users will have it installed, but provide old script-based fallback just in case
    if Command::new("xcode-select").stdout(Stdio::null()).arg("-p").status().is_ok() {
        let loader_source_content = format!(
            r#"import Foundation
let task = Process()
task.launchPath = "{exe}"
task.arguments = ["site", "launch", "--direct-launch", "{ulid}"] + CommandLine.arguments[1...]
task.launch()
task.waitUntilExit()
"#
        );

        let mut loader_source_file = tempfile::Builder::new()
            .prefix("firefoxpwa-loader-")
            .suffix(".swift")
            .tempfile()
            .context(CREATE_TEMP_FILE_ERROR)?;

        loader_source_file
            .as_file_mut()
            .write_all(loader_source_content.as_bytes())
            .context("Failed to write loader source")?;

        Command::new("swiftc")
            .arg("-O")
            .arg("-o")
            .arg(loader)
            .arg(loader_source_file.path().as_os_str())
            .status()
            .context("Failed to compile loader source")?;
    } else {
        warn!("Could not find Command Line Tools for Xcode");
        warn!("Falling back to the legacy script-based loader");
        warn!("Tools can be installed using: xcode-select --install");
        warn!("After installing, update your web app to apply changes");

        #[rustfmt::skip]
        let loader_content = format!("#!/usr/bin/env sh\n\n{exe} site launch --direct-launch {ulid} \"$@\"\n");
        let mut loader_file = File::create(loader).context(WRITE_APPLICATION_FILE_ERROR)?;
        let loader_permissions = Permissions::from_mode(0o755);
        loader_file.set_permissions(loader_permissions).context(WRITE_APPLICATION_FILE_ERROR)?;
        loader_file.write_all(loader_content.as_ref()).context(WRITE_APPLICATION_FILE_ERROR)?;
    }

    // Update icons if needed
    if args.update_icons {
        store_icons(&resources_dir, &name, &args.site.icons(), args.client.unwrap())
            .context(STORE_ICONS_ERROR)?;
    }

    // Our app bundle is not signed with an Apple developer certificate
    // By removing the quarantine attribute we can skip the signature verification
    Command::new("xattr")
        .args(["-rd", "com.apple.quarantine", bundle.to_str().unwrap()])
        .output()?;

    Ok(())
}

fn create_desktop_entry(
    args: &IntegrationInstallArgs,
    ids: &SiteIds,
    exe: &str,
    data: &Path,
) -> Result<()> {
    // Process some known manifest categories and reformat them into XDG names
    let mut categories = vec![];
    for category in args.site.categories() {
        // Normalize category name for easier matching
        let category = normalize_category_name(&category);

        // Get the mapped XDG category based on the site categories
        if let Some(category) = XDG_CATEGORIES.get(&category) {
            categories.extend_from_slice(category);
        }
    }
    categories.sort_unstable();
    categories.dedup();

    // Get the .desktop filename in the applications directory
    let directory = data.join("applications");
    let filename = directory.join(format!("{}.desktop", ids.classid));

    // Store entry data
    let mut entry = format!(
        "[Desktop Entry]
Type=Application
Version=1.4
Name={name}
Comment={description}
Keywords={keywords};
Categories=GTK;WebApps;{categories};
Icon={icon}
Exec={exe} site launch {id} --protocol %u
Actions={actions}
MimeType={protocols}
Terminal=false
StartupNotify=true
StartupWMClass={wmclass}
",
        id = &ids.ulid,
        name = &ids.name,
        description = &ids.description,
        keywords = &args.site.keywords().join(";"),
        categories = &categories.join(";"),
        actions = (0..args.site.manifest.shortcuts.len()).fold(String::new(), |mut output, i| {
            let _ = write!(output, "{i};");
            output
        }),
        protocols = args.site.config.enabled_protocol_handlers.iter().fold(
            String::new(),
            |mut output, protocol| {
                let _ = write!(output, "x-scheme-handler/{};", sanitize_string(protocol));
                output
            }
        ),
        icon = &ids.classid,
        wmclass = &ids.classid,
        exe = &exe,
    );

    // Store all shortcuts
    for (i, shortcut) in args.site.manifest.shortcuts.iter().enumerate() {
        let name = sanitize_string(&shortcut.name);
        let url: Url = shortcut.url.clone().try_into().context(CONVERT_SHORTCUT_URL_ERROR)?;
        let icon = format!("{}-{}", ids.classid, i);

        if args.update_icons {
            store_icons(&icon, &name, &shortcut.icons, data, args.client.unwrap())
                .context("Failed to store shortcut icons")?;
        }

        let action = format!(
            "
[Desktop Action {actionid}]
Name={name}
Icon={icon}
Exec={exe} site launch {siteid} --url \"{url}\"
",
            actionid = i,
            siteid = &ids.ulid,
            name = &name,
            icon = &icon,
            url = &url,
            exe = &exe,
        );

        entry += &action;
    }

    // Create the directory and write the file
    create_dir_all(directory).context(CREATE_APPLICATION_DIRECTORY_ERROR)?;
    write(filename, entry).context(WRITE_APPLICATION_FILE_ERROR)?;

    Ok(())
}

fn create_jump_list_tasks(
    args: &IntegrationInstallArgs,
    ids: &SiteIds,
    exe: &str,
    icons: &Path,
) -> Result<()> {
    let shortcuts = &args.site.manifest.shortcuts;

    // Create jump list and set its app ID and number of tasks
    let list: ICustomDestinationList = create_instance(&DestinationList)?;

    unsafe {
        if shortcuts.is_empty() {
            list.DeleteList(&HSTRING::from(&ids.appid))?;
            return Ok(());
        } else {
            list.SetAppID(&HSTRING::from(&ids.appid))?;
            let _: IObjectArray = list.BeginList(&mut (shortcuts.len() as u32))?;
        }
    }

    // Create task collection and add tasks
    let collection: IObjectCollection = create_instance(&EnumerableObjectCollection)?;

    for (i, shortcut) in shortcuts.iter().enumerate() {
        let url: Url = shortcut.url.clone().try_into().context("Failed to convert shortcut URL")?;
        let name = sanitize_string(&shortcut.name);
        let description = sanitize_string(shortcut.description.as_deref().unwrap_or(""));
        let icon = icons.join(format!("shortcut{i}.ico",));

        if args.update_icons {
            store_icon(&name, &shortcut.icons, &icon, args.client.unwrap())
                .context("Failed to store shortcut icon")?;
        }

        // Create shell link and property store instances
        let link: IShellLinkW = create_instance(&ShellLink)?;
        let store: IPropertyStore = link.cast()?;

        unsafe {
            // Set general shortcut properties
            link.SetPath(&HSTRING::from(exe))?;
            link.SetArguments(&HSTRING::from(format!("site launch {} --url {}", ids.ulid, url)))?;
            link.SetDescription(&HSTRING::from(description.chars().take(240).collect::<String>()))?;
            link.SetIconLocation(&HSTRING::from(icon.display().to_string()), 0)?;
            link.SetShowCmd(SW_SHOWMINNOACTIVE)?;

            // Set app user model ID property
            // Docs: https://docs.microsoft.com/en-us/windows/win32/properties/props-system-appusermodel-id
            let hstring = HSTRING::from(&ids.appid);
            let variant = InitPropVariantFromStringVector(Some(&[PCWSTR(hstring.as_ptr())]))?;
            store.SetValue(&PKEY_AppUserModel_ID, &variant)?;

            // Set title property
            // Docs: https://docs.microsoft.com/en-us/windows/win32/properties/props-system-title
            let hstring = HSTRING::from(&name);
            let variant = InitPropVariantFromStringVector(Some(&[PCWSTR(hstring.as_ptr())]))?;
            store.SetValue(&PKEY_Title, &variant)?;

            // Commit store and add it to collection
            store.Commit()?;
            collection.AddObject(&link)?;
        }
    }

    unsafe {
        // Add all tasks to the jump list
        let tasks: IObjectArray = collection.cast()?;
        list.AddUserTasks(&tasks)?;
        list.CommitList()?;
    }

    Ok(())
}

pub fn description(&self) -> String {
        sanitize_string(
            &self
                .config
                .description
                .as_ref()
                .cloned()
                .or_else(|| self.manifest.description.as_ref().cloned())
                .unwrap_or_else(|| "".into()),
        )
    }

pub fn keywords(&self) -> Vec<String> {
        match &self.config.keywords {
            Some(keywords) => keywords,
            None => &self.manifest.keywords,
        }
        .iter()
        .map(|item| sanitize_string(item))
        .collect()
    }

pub fn name(&self) -> String {
        sanitize_string(
            &self
                .config
                .name
                .as_ref()
                .cloned()
                .or_else(|| self.manifest.name.as_ref().cloned())
                .or_else(|| self.manifest.short_name.as_ref().cloned())
                .unwrap_or_else(|| self.domain()),
        )
    }

fn process(&self, connection: &Connection) -> Result<ConnectorResponse> {
        Ok(ConnectorResponse::SystemVersions {
            firefoxpwa: Some(env!("CARGO_PKG_VERSION").into()),
            firefox: Runtime::new(connection.dirs)?.version,
            _7zip: {
                cfg_if! {
                    if #[cfg(platform_windows)] {
                        use crate::components::_7zip::_7Zip;
                        _7Zip::new()?.version
                    } else {
                        None
                    }
                }
            },
        })
    }

fn register_protocol_handlers(
    args: &IntegrationInstallArgs,
    ids: &SiteIds,
    exe: &str,
    icon: &str,
) -> Result<()> {
    let assign_values = |key: RegKey| -> Result<()> {
        key.set_value("ApplicationName", &ids.name)
            .context("Failed to set ApplicationName application key")?;
        key.set_value("ApplicationDescription", &ids.description)
            .context("Failed to set ApplicationDescription application key")?;
        key.set_value("ApplicationIcon", &format!("{icon},0"))
            .context("Failed to set ApplicationIcon application key")?;
        key.set_value("AppUserModelID", &ids.appid)
            .context("Failed to set AppUserModelID application key")?;
        Ok(())
    };

    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let capabilities_path = format!(r"Software\filips\FirefoxPWA\{}\Capabilities", ids.regid);
    let classes_path = format!(r"Software\Classes\{}", ids.regid);

    // Add web app to a list of registered applications
    let (registered_applications, _) = hkcu
        .create_subkey(REGISTERED_APPLICATIONS_KEY)
        .context("Failed to open RegisteredApplications list")?;
    registered_applications
        .set_value(&ids.regid, &capabilities_path)
        .context("Failed to add to RegisteredApplications list")?;

    // Register application details
    let (application, _) = hkcu
        .create_subkey(format!(r"{classes_path}\Application"))
        .context("Failed to create application registry key")?;
    let (capabilities, _) = hkcu
        .create_subkey(&capabilities_path)
        .context("Failed to create capabilities registry key")?;
    assign_values(application).context("Failed to set application registry key")?;
    assign_values(capabilities).context("Failed to set capabilities registry key")?;

    // Register application open commands
    let ulid = &ids.ulid;
    let (open_command, _) = hkcu
        .create_subkey(format!(r"{classes_path}\Shell\open\command"))
        .context("Failed to create open command registry key")?;
    open_command
        .set_value("", &format!("\"{exe}\" site launch {ulid} --protocol \"%1\""))
        .context("Failed to set open command registry key")?;

    // Create URL associations key
    let (associations, _) = hkcu
        .create_subkey(format!(r"{capabilities_path}\UrlAssociations"))
        .context("Failed to create URL associations registry key")?;

    // Remove existing protocol handlers
    for (protocol, _) in associations.enum_values().filter_map(|item| item.ok()) {
        let _ = associations.delete_value(protocol);
    }

    // Add enabled protocol handlers
    for protocol in &args.site.config.enabled_protocol_handlers {
        associations
            .set_value(sanitize_string(protocol), &ids.regid)
            .context("Failed to set protocol registry key")?;
    }

    Ok(())
}

fn run(&self) -> Result<()> {
        let dirs = ProjectDirs::new()?;
        let storage = Storage::load(&dirs)?;

        for (_, profile) in storage.profiles {
            println!(
                "{:=^60}\nDescription: {}\nID: {}",
                format!(
                    " {} ",
                    sanitize_string(&profile.name.unwrap_or_else(|| "* Unnamed *".into()))
                ),
                sanitize_string(&profile.description.unwrap_or_else(|| "* Nothing *".into())),
                profile.ulid
            );

            if !profile.sites.is_empty() {
                println!("\nApps:");
            }

            for site in profile.sites {
                let site = storage.sites.get(&site).context("Profile with invalid web app")?;

                let url = if site.config.manifest_url.scheme() != "data" {
                    &site.config.manifest_url
                } else {
                    &site.config.document_url
                };

                println!("- {}: {} ({})", site.name(), url, site.ulid);
            }

            println!();
        }

        Ok(())
    }

pub fn sanitize_string(string: &str) -> String {
    string.chars().filter(|char| !char.is_control()).collect()
}

